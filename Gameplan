21-Day Music Analysis Web App Workbook
ðŸ“† Week 1 â€” Frontend & API Basics
Focus: HTML forms, JavaScript fetch, APIs, JSON handling.

        Day 1 â€” HTML Basics for Forms & Buttons
        Concept & Why It Matters
        Forms and buttons are the bridge between your user and your app. They collect input and send it to your backend.

        Core Commands

        <input type="text">, <input type="file">

        <button>

        document.getElementById()

        .addEventListener()

        Guided Example

        html
        Kopieren
        Bearbeiten
        <input type="file" id="fileInput">
        <button id="btn">Click me</button>
        <script>
        document.getElementById("btn").addEventListener("click", () => {
            alert("Button clicked!");
        });
        </script>
        Challenges

        Create an HTML page with a text input and a button that alerts the entered text.

        Make a file input that logs the selected file name in the console.

        Style your button using CSS to have a blue background.

        Day 2 â€” JavaScript fetch() for GET Requests
        Concept & Why It Matters
        fetch() is how JavaScript retrieves data from APIs â€” essential for connecting your frontend to your backend.

        Core Commands

        fetch(url)

        .then()

        response.json()

        console.log()

        Guided Example

        html
        Kopieren
        Bearbeiten
        <button id="loadBtn">Load Data</button>
        <div id="output"></div>
        <script>
        document.getElementById("loadBtn").addEventListener("click", () => {
            fetch("https://jsonplaceholder.typicode.com/todos/1")
              .then(res => res.json())
              .then(data => {
                  document.getElementById("output").innerText = JSON.stringify(data);
              });
        });
        </script>
        Challenges

        Change the API URL to fetch a different TODO (id=5).

        Display only the title field from the fetched JSON.

        Make two buttons: one loads TODO #1, the other loads TODO #2.


Upload Data (.csv)
Change to JSON (in JS)
Send to Python (Read something from Data)
Convert Results to JSON
Send to JS
Output on Webinterface



















Day 3 â€” Understanding JSON
Concept & Why It Matters
JSON is the most common format for exchanging data between frontend and backend.

Core Commands

JS: JSON.stringify(), JSON.parse()

Python: jsonify(), json.dumps(), json.loads()

Guided Example

js
Kopieren
Bearbeiten
let obj = {name: "Alex", age: 25};
let jsonStr = JSON.stringify(obj);
console.log(jsonStr);

python
Kopieren
Bearbeiten
from flask import Flask, jsonify
app = Flask(__name__)
@app.route("/")
def home():
    return jsonify({"name": "Alex", "age": 25})
Challenges

Fetch user #3 from jsonplaceholder and log only the username.

Convert {genre: "Jazz"} to JSON and log it.

In Flask, return a JSON object with your name and todayâ€™s date.

Day 4 â€” HTML Forms & POST Requests
Concept & Why It Matters
Forms + POST requests let you send user data (text, files) to a server.

Core Commands

<form method="POST">

JS: FormData()

fetch with { method: 'POST' }

Guided Example

html
Kopieren
Bearbeiten
<form id="myForm">
  <input type="text" name="username">
  <button type="submit">Send</button>
</form>
<script>
document.getElementById("myForm").addEventListener("submit", (e) => {
    e.preventDefault();
    const formData = new FormData(e.target);
    fetch("/api", { method: "POST", body: formData });
});
</script>
Challenges

Make a form with name + email, log it in console before sending.

Send the form data to /test and check the network tab.

Modify the form to include a file input.

Day 5 â€” Intro to Flask Backend
Concept & Why It Matters
Flask will handle your API routes, process requests, and return responses to JS.

Core Commands

Flask()

@app.route()

request.form, request.files

Guided Example

python
Kopieren
Bearbeiten
from flask import Flask, request, jsonify
app = Flask(__name__)

@app.route("/upload", methods=["POST"])
def upload():
    file = request.files["file"]
    return jsonify({"filename": file.filename})

if __name__ == "__main__":
    app.run(debug=True)
Challenges

Create a /hello route that returns {"message": "Hi there"}.

Make a /echo POST route that returns whatever was sent in request.form.

Return both form data and uploaded file name in one JSON.

Day 6 â€” Connecting Frontend & Backend
Concept & Why It Matters
This is where your HTML/JS and Flask backend actually communicate.

Core Commands

JS: fetch('/route', { method: 'POST', body: formData })

Flask: request.form, request.files

Guided Example

html
Kopieren
Bearbeiten
<form id="fileForm">
  <input type="file" name="file">
  <button>Upload</button>
</form>
<script>
document.getElementById("fileForm").addEventListener("submit", (e) => {
    e.preventDefault();
    const fd = new FormData(e.target);
    fetch("/upload", { method: "POST", body: fd })
      .then(res => res.json())
      .then(data => console.log(data));
});
</script>
Challenges

Upload a text file and return its size from Flask.

Upload an image and return its dimensions using Pillow.

Display the returned JSON in the HTML instead of console.

Day 7 â€” Serving Static Files in Flask
Concept & Why It Matters
Your HTML/JS/CSS files need to be accessible through Flask.

Core Commands

app = Flask(__name__, static_folder="static", template_folder="templates")

render_template()

Guided Example

python
Kopieren
Bearbeiten
from flask import Flask, render_template
app = Flask(__name__, template_folder="templates")

@app.route("/")
def index():
    return render_template("index.html")
Challenges

Serve an index.html file.

Add a linked CSS file and check it loads.

Add a JS file and log a message from it.

ðŸ“† Week 2 â€” Audio Processing & Data Handling
Focus: File uploads, Librosa basics, returning extracted features to frontend.

Day 8 â€” Installing & Testing Librosa
Concept & Why It Matters
Librosa is a Python library for analyzing audio. Weâ€™ll use it to extract music features from uploaded files.

Core Commands

pip install librosa

librosa.load()

librosa.get_duration()

Guided Example

python
Kopieren
Bearbeiten
import librosa

y, sr = librosa.load("example.mp3")
print("Sample rate:", sr)
print("Duration:", librosa.get_duration(y=y, sr=sr))
Challenges

Load an audio file and print its sample rate.

Print the duration in seconds.

Test loading a WAV and an MP3 file â€” note the differences.

Day 9 â€” Extracting Basic Audio Features
Concept & Why It Matters
Feature extraction is the heart of music analysis â€” weâ€™ll start simple with tempo and spectral centroid.

Core Commands

librosa.beat.tempo()

librosa.feature.spectral_centroid()

Guided Example

python
Kopieren
Bearbeiten
y, sr = librosa.load("example.mp3")
tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
print("Tempo:", tempo)
Challenges

Extract tempo from your own audio file.

Compute the average spectral centroid and print it.

Extract both and return as a Python dict.

Day 10 â€” Returning Features via Flask API
Concept & Why It Matters
Once we can extract features in Python, we need to send them to the frontend.

Core Commands

Flask: jsonify()

Handling file uploads with request.files

Guided Example

python
Kopieren
Bearbeiten
from flask import Flask, request, jsonify
import librosa

app = Flask(__name__)

@app.route("/analyze", methods=["POST"])
def analyze():
    file = request.files["file"]
    y, sr = librosa.load(file)
    tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
    return jsonify({"tempo": float(tempo)})

if __name__ == "__main__":
    app.run(debug=True)
Challenges

Add spectral centroid to the returned JSON.

Add duration to the returned JSON.

Test the API with curl or Postman.

Day 11 â€” Displaying Audio Features in JS
Concept & Why It Matters
Your frontend should take the JSON from Flask and present it nicely.

Core Commands

.innerText / .innerHTML

String interpolation ${variable}

Guided Example

html
Kopieren
Bearbeiten
<form id="audioForm">
  <input type="file" name="file">
  <button>Analyze</button>
</form>
<div id="results"></div>

<script>
document.getElementById("audioForm").addEventListener("submit", e => {
    e.preventDefault();
    const fd = new FormData(e.target);
    fetch("/analyze", { method: "POST", body: fd })
      .then(res => res.json())
      .then(data => {
          document.getElementById("results").innerHTML =
            `Tempo: ${data.tempo} BPM`;
      });
});
</script>
Challenges

Show duration in seconds as well.

Add styling to make the results look like a card.

Make the output update without refreshing the page.

Day 12 â€” Adding More Audio Features
Concept & Why It Matters
The more features, the richer your dataset for future ML tasks.

Possible Features

Chroma features: librosa.feature.chroma_stft()

Zero-crossing rate: librosa.feature.zero_crossing_rate()

Guided Example

python
Kopieren
Bearbeiten
zcr = librosa.feature.zero_crossing_rate(y)
print("Zero-crossing rate:", zcr.mean())
Challenges

Extract zero-crossing rate.

Extract chroma_stft mean values.

Return them in your Flask JSON response.

Day 13 â€” Sending Multiple Features to JS
Concept & Why It Matters
Handling multi-field JSON responses is a core skill for frontend data handling.

Guided Example

js
Kopieren
Bearbeiten
fetch("/analyze", { method: "POST", body: fd })
  .then(res => res.json())
  .then(data => {
    document.getElementById("results").innerHTML = `
      Tempo: ${data.tempo} BPM<br>
      Duration: ${data.duration} s<br>
      ZCR: ${data.zcr}
    `;
  });
Challenges

Loop over all keys in the JSON and display them dynamically.

Format numbers to 2 decimal places.

Add a timestamp of when analysis was done.

Day 14 â€” Frontend Polishing
Concept & Why It Matters
A professional look makes your app more impressive to employers.

Guided Example

css
Kopieren
Bearbeiten
#results {
  background: #eee;
  padding: 1rem;
  border-radius: 5px;
}
Challenges

Style the upload form to be centered.

Add a hover effect on the button.

Make results appear with a fade-in animation.

ðŸ“† Week 3 â€” Visualization, Extra Features & MVP Launch
Focus: Graphs, optional ML, final deployment.

Day 15 â€” Adding Charts with Chart.js
Concept & Why It Matters
Charts make your analysis more intuitive and visually appealing.

Core Commands

Include Chart.js via <script src="..."></script>

new Chart(ctx, {...})

Guided Example

html
Kopieren
Bearbeiten
<canvas id="myChart"></canvas>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
const ctx = document.getElementById('myChart');
new Chart(ctx, {
    type: 'bar',
    data: {
        labels: ['Tempo', 'ZCR'],
        datasets: [{
            label: 'Values',
            data: [120, 0.05]
        }]
    }
});
</script>
Challenges

Show tempo and ZCR from your API dynamically.

Add a third bar for duration.

Change colors to match your theme.

Day 16 â€” Visualizing Waveforms
Concept & Why It Matters
Waveforms give users a quick view of the audio structure.

Tools

librosa.display.waveshow() (backend-generated image)

Serve image to frontend

Guided Example (Python)

python
Kopieren
Bearbeiten
import matplotlib.pyplot as plt
import librosa.display

y, sr = librosa.load("example.mp3")
plt.figure()
librosa.display.waveshow(y, sr=sr)
plt.savefig("static/waveform.png")
Challenges

Generate waveform for uploaded file.

Return path in JSON and display in HTML.

Style the image nicely.

Day 17 â€” Optional ML Integration
Concept & Why It Matters
You can train a tiny classifier to predict genre from features â€” even if itâ€™s simple, it shows ML skills.

Guided Example

python
Kopieren
Bearbeiten
from sklearn.ensemble import RandomForestClassifier
# Train on a small dataset of features -> genre
Challenges

Collect 5â€“10 sample songs with features + labels.

Train a RandomForest on them.

Predict genre for uploaded file.

Day 18 â€” Error Handling & Validation
Concept & Why It Matters
A polished app handles bad inputs gracefully.

Challenges

Show an error if no file is uploaded.

Check file extension before sending.

Show a friendly message if the backend errors.

Day 19 â€” Testing Full Workflow
Concept & Why It Matters
Run through your app like a real user.

Challenges

Test with 3 different audio files.

Check API calls in the browser network tab.

Fix any UI glitches.

Day 20 â€” Final Styling & UX Improvements
Challenges

Add a loading spinner during analysis.

Make layout mobile-friendly.

Add your name and a brief description at the bottom.

Day 21 â€” MVP Launch
Challenges

Have a working HTML + JS frontend that uploads an audio file to Flask.

Backend extracts features and returns JSON.

Frontend displays features in text + chart.

Your app is now ready for your portfolio.